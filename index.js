'use strict';

var fs = require('fs');

var boolOptions = [
	'autoLeftMargin',
	'autoRightMargin',
	'noEscCtlc',
	'ceolStandoutGlitch',
	'eatNewlineGlitch',
	'eraseOverstrike',
	'genericType',
	'hardCopy',
	'hasMetaKey',
	'hasStatusLine',
	'insertNullGlitch',
	'memoryAbove',
	'memoryBelow',
	'moveInsertMode',
	'moveStandoutMode',
	'overStrike',
	'statusLineEscOk',
	'destTabsMagicSmso',
	'tildeGlitch',
	'transparentUnderline',
	'xonXoff',
	'needsXonXoff',
	'prtrSilent',
	'hardCursor',
	'nonRevRmcup',
	'noPadChar',
	'nonDestScrollRegion',
	'canChange',
	'backColorErase',
	'hueLightnessSaturation',
	'colAddrGlitch',
	'crCancelsMicroMode',
	'hasPrintWheel',
	'rowAddrGlitch',
	'semiAutoRightMargin',
	'cpiChangesRes',
	'lpiChangesRes'
];

var numberOptions = [
	'columns',
	'initTabs',
	'lines',
	'linesOfMemory',
	'magicCookieGlitch',
	'paddingBaudRate',
	'virtualTerminal',
	'widthStatusLine',
	'numLabels',
	'labelHeight',
	'labelWidth',
	'maxAttributes',
	'maximumWindows',
	'maxColors',
	'maxPairs',
	'noColorVideo',
	'bufferCapacity',
	'dotVertSpacing',
	'dotHorzSpacing',
	'maxMicroAddress',
	'maxMicroJump',
	'microColSize',
	'microLineSize',
	'numberOfPins',
	'outputResChar',
	'outputResLine',
	'outputResHorzInch',
	'outputResVertInch',
	'printRate',
	'wideCharSize',
	'buttons',
	'bitImageEntwining',
	'bitImageType'
];

var stringOptions = [
	'backTab',
	'bell',
	'carriageReturn',
	'changeScrollRegion',
	'clearAllTabs',
	'clearScreen',
	'clrEol',
	'clrEos',
	'columnAddress',
	'commandCharacter',
	'cursorAddress',
	'cursorDown',
	'cursorHome',
	'cursorInvisible',
	'cursorLeft',
	'cursorMemAddress',
	'cursorNormal',
	'cursorRight',
	'cursorToLl',
	'cursorUp',
	'cursorVisible',
	'deleteCharacter',
	'deleteLine',
	'disStatusLine',
	'downHalfLine',
	'enterAltCharsetMode',
	'enterBlinkMode',
	'enterBoldMode',
	'enterCaMode',
	'enterDeleteMode',
	'enterDimMode',
	'enterInsertMode',
	'enterSecureMode',
	'enterProtectedMode',
	'enterReverseMode',
	'enterStandoutMode',
	'enterUnderlineMode',
	'eraseChars',
	'exitAltCharsetMode',
	'exitAttributeMode',
	'exitCaMode',
	'exitDeleteMode',
	'exitInsertMode',
	'exitStandoutMode',
	'exitUnderlineMode',
	'flashScreen',
	'formFeed',
	'fromStatusLine',
	'init1String',
	'init2String',
	'init3String',
	'initFile',
	'insertCharacter',
	'insertLine',
	'insertPadding',
	'keyBackspace',
	'keyCatab',
	'keyClear',
	'keyCtab',
	'keyDc',
	'keyDl',
	'keyDown',
	'keyEic',
	'keyEol',
	'keyEos',
	'keyF0',
	'keyF1',
	'keyF10',
	'keyF2',
	'keyF3',
	'keyF4',
	'keyF5',
	'keyF6',
	'keyF7',
	'keyF8',
	'keyF9',
	'keyHome',
	'keyIc',
	'keyIl',
	'keyLeft',
	'keyLl',
	'keyNpage',
	'keyPpage',
	'keyRight',
	'keySf',
	'keySr',
	'keyStab',
	'keyUp',
	'keypadLocal',
	'keypadXmit',
	'labF0',
	'labF1',
	'labF10',
	'labF2',
	'labF3',
	'labF4',
	'labF5',
	'labF6',
	'labF7',
	'labF8',
	'labF9',
	'metaOff',
	'metaOn',
	'newline',
	'padChar',
	'parmDch',
	'parmDeleteLine',
	'parmDownCursor',
	'parmIch',
	'parmIndex',
	'parmInsertLine',
	'parmLeftCursor',
	'parmRightCursor',
	'parmRindex',
	'parmUpCursor',
	'pkeyKey',
	'pkeyLocal',
	'pkeyXmit',
	'printScreen',
	'prtrOff',
	'prtrOn',
	'repeatChar',
	'reset1String',
	'reset2String',
	'reset3String',
	'resetFile',
	'restoreCursor',
	'rowAddress',
	'saveCursor',
	'scrollForward',
	'scrollReverse',
	'setAttributes',
	'setTab',
	'setWindow',
	'tab',
	'toStatusLine',
	'underlineChar',
	'upHalfLine',
	'initProg',
	'keyA1',
	'keyA3',
	'keyB2',
	'keyC1',
	'keyC3',
	'prtrNon',
	'charPadding',
	'acsChars',
	'plabNorm',
	'keyBtab',
	'enterXonMode',
	'exitXonMode',
	'enterAmMode',
	'exitAmMode',
	'xonCharacter',
	'xoffCharacter',
	'enaAcs',
	'labelOn',
	'labelOff',
	'keyBeg',
	'keyCancel',
	'keyClose',
	'keyCommand',
	'keyCopy',
	'keyCreate',
	'keyEnd',
	'keyEnter',
	'keyExit',
	'keyFind',
	'keyHelp',
	'keyMark',
	'keyMessage',
	'keyMove',
	'keyNext',
	'keyOpen',
	'keyOptions',
	'keyPrevious',
	'keyPrint',
	'keyRedo',
	'keyReference',
	'keyRefresh',
	'keyReplace',
	'keyRestart',
	'keyResume',
	'keySave',
	'keySuspend',
	'keyUndo',
	'keySbeg',
	'keyScancel',
	'keyScommand',
	'keyScopy',
	'keyScreate',
	'keySdc',
	'keySdl',
	'keySelect',
	'keySend',
	'keySeol',
	'keySexit',
	'keySfind',
	'keyShelp',
	'keyShome',
	'keySic',
	'keySleft',
	'keySmessage',
	'keySmove',
	'keySnext',
	'keySoptions',
	'keySprevious',
	'keySprint',
	'keySredo',
	'keySreplace',
	'keySright',
	'keySrsume',
	'keySsave',
	'keySsuspend',
	'keySundo',
	'reqForInput',
	'keyF11',
	'keyF12',
	'keyF13',
	'keyF14',
	'keyF15',
	'keyF16',
	'keyF17',
	'keyF18',
	'keyF19',
	'keyF20',
	'keyF21',
	'keyF22',
	'keyF23',
	'keyF24',
	'keyF25',
	'keyF26',
	'keyF27',
	'keyF28',
	'keyF29',
	'keyF30',
	'keyF31',
	'keyF32',
	'keyF33',
	'keyF34',
	'keyF35',
	'keyF36',
	'keyF37',
	'keyF38',
	'keyF39',
	'keyF40',
	'keyF41',
	'keyF42',
	'keyF43',
	'keyF44',
	'keyF45',
	'keyF46',
	'keyF47',
	'keyF48',
	'keyF49',
	'keyF50',
	'keyF51',
	'keyF52',
	'keyF53',
	'keyF54',
	'keyF55',
	'keyF56',
	'keyF57',
	'keyF58',
	'keyF59',
	'keyF60',
	'keyF61',
	'keyF62',
	'keyF63',
	'clrBol',
	'clearMargins',
	'setLeftMargin',
	'setRightMargin',
	'labelFormat',
	'setClock',
	'displayClock',
	'removeClock',
	'createWindow',
	'gotoWindow',
	'hangup',
	'dialPhone',
	'quickDial',
	'tone',
	'pulse',
	'flashHook',
	'fixedPause',
	'waitTone',
	'user0',
	'user1',
	'user2',
	'user3',
	'user4',
	'user5',
	'user6',
	'user7',
	'user8',
	'user9',
	'origPair',
	'origColors',
	'initializeColor',
	'initializePair',
	'setColorPair',
	'setForeground',
	'setBackground',
	'changeCharPitch',
	'changeLinePitch',
	'changeResHorz',
	'changeResVert',
	'defineChar',
	'enterDoublewideMode',
	'enterDraftQuality',
	'enterItalicsMode',
	'enterLeftwardMode',
	'enterMicroMode',
	'enterNearLetterQuality',
	'enterNormalQuality',
	'enterShadowMode',
	'enterSubscriptMode',
	'enterSuperscriptMode',
	'enterUpwardMode',
	'exitDoublewideMode',
	'exitItalicsMode',
	'exitLeftwardMode',
	'exitMicroMode',
	'exitShadowMode',
	'exitSubscriptMode',
	'exitSuperscriptMode',
	'exitUpwardMode',
	'microColumnAddress',
	'microDown',
	'microLeft',
	'microRight',
	'microRowAddress',
	'microUp',
	'orderOfPins',
	'parmDownMicro',
	'parmLeftMicro',
	'parmRightMicro',
	'parmUpMicro',
	'selectCharSet',
	'setBottomMargin',
	'setBottomMarginParm',
	'setLeftMarginParm',
	'setRightMarginParm',
	'setTopMargin',
	'setTopMarginParm',
	'startBitImage',
	'startCharSetDef',
	'stopBitImage',
	'stopCharSetDef',
	'subscriptCharacters',
	'superscriptCharacters',
	'theseCauseCr',
	'zeroMotion',
	'charSetNames',
	'keyMouse',
	'mouseInfo',
	'reqMousePos',
	'getMouse',
	'setAForeground',
	'setABackground',
	'pkeyPlab',
	'deviceType',
	'codeSetInit',
	'set0DesSeq',
	'set1DesSeq',
	'set2DesSeq',
	'set3DesSeq',
	'setLrMargin',
	'setTbMargin',
	'bitImageRepeat',
	'bitImageNewline',
	'bitImageCarriageReturn',
	'colorNames',
	'defineBitImageRegion',
	'endBitImageRegion',
	'setColorBand',
	'setPageLength',
	'displayPcChar',
	'enterPcCharsetMode',
	'exitPcCharsetMode',
	'enterScancodeMode',
	'exitScancodeMode',
	'pcTermOptions',
	'scancodeEscape',
	'altScancodeEsc',
	'enterHorizontalHlMode',
	'enterLeftHlMode',
	'enterLowHlMode',
	'enterRightHlMode',
	'enterTopHlMode',
	'enterVerticalHlMode',
	'setAAttributes',
	'setPglenInch'
];

function getTerminfoBuffer(name) {
	var path;
	try {
		path = '/usr/share/terminfo/' + name.charCodeAt(0).toString(16).toUpperCase() + '/' + name;
		return {path: path, buf: fs.readFileSync(path)};
	} catch (e) {
		try {
			path = '/usr/share/terminfo/' + name[0] + '/' + name;
			return {path: path, buf: fs.readFileSync(path)};
		} catch (e) {
			throw new Error('unknown TERM name: ' + name);
		}
	}
}

function toCString(buf, offset) {
	var end = offset;
	while (buf[end++] !== 0) { /* :) */ }
	return buf.toString('ascii', offset, end - 1);
}

function parseTermBuffer(bufPair, name) {
	var buf = bufPair.buf;
	var offset = 0;
	var i;

	// magic number
	var magic = buf.readInt16LE(offset);
	offset += 2;

	if (magic !== 0x11A) {
		throw new Error('terminfo for ' + name + ' has invalid magic number');
	}

	var result = {
		path: bufPair.path,
		namesSize: buf.readInt16LE(offset),
		boolSize: buf.readInt16LE(offset + 2),
		numCount: buf.readInt16LE(offset + 4),
		offCount: buf.readInt16LE(offset + 6),
		strSize: buf.readInt16LE(offset + 8)
	};
	offset += 10;

	// names (usually a descriptive name along with the $TERM name)
	result.names = buf.toString('ascii', offset, offset + result.namesSize - 1).split('|');
	offset += result.namesSize;

	// bools
	if (result.boolSize < boolOptions.length) {
		throw new Error('terminfo for ' + name + ' has invalid boolean section size (' + result.boolSize + ' < ' + boolOptions.length + ')');
	}

	boolOptions.forEach(function (opt, i) {
		result[opt] = Boolean(buf.readInt8(offset + i));
	});
	offset += result.boolSize;
	offset += offset % 2; // shorts are aligned to short boundary in file

	// numbers
	for (i = 0; i < result.numCount && i < numberOptions.length; i++) {
		var num = buf.readInt16LE(offset + (2 * i));
		if (num !== -1) {
			result[numberOptions[i]] = num;
		}
	}
	offset += 2 * result.numCount;

	// strings
	var offsetTable = offset + (result.offCount * 2);
	for (i = 0; i < result.offCount && i < stringOptions.length; i++) {
		var off = buf.readInt16LE(offset + (2 * i));
		if (off !== -1) {
			result[stringOptions[i]] = toCString(buf, offsetTable + off);
		}
	}

	return result;
}

module.exports = function (term) {
	term = term || process.env.TERM || 'dummy';

	var infoBuffer = getTerminfoBuffer(term);
	return parseTermBuffer(infoBuffer, term);
};
